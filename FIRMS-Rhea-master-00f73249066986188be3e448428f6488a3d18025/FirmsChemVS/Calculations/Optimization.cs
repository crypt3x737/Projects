using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.SolverFoundation.Solvers;


namespace FirmsChemVS.Services
{
    public class Optimization
    {
        static void optimizeAbundance( List<double> elem, Abundance data )
         {
            //Generate numerators for each mu calculation
            data.numeratorGen(elem);

            //The code here should ideally generate the mu values for each 
            //associated daughter ion. This should essentially line up with the
            //"Calculated Abundance" column in the bottom excel portion in the FIRMS
            //Program. The only thing that might be off right now is the numeratorGen
            //function up above, since I'm currently unsure if it is properly generating
            //the top part of each mu calculation. These need to be proceduraly generated
            //rather than input by the user in the interface. If there are any inaccuracies with the
            //program, they are likely in that part.


            //mu = alpha * numerator / sigmaT
            //where numerator = sum of sigmas
            for( int i = 0; i < data.total(); i++ )
            {
                data.mu[i] = (data.alphas[i] * data.numerators[i]) / data.getSigmaT();
            }
         }

        static Double solveAbundance(double[] x, Abundance data)
        {
            //Run optimization using current guesses
            optimizeAbundance(x.ToList(), data);

            //Count iterations
            data.incIterations();

            //Calculate error (which is what we're trying to minimize...
            Double err = errorAbundance(x.ToList(), data);

            //Feel free to debug here, or print out err to see how this is converging...
            return err;
        }

        static Double errorAbundance(List<double> x, Abundance data)
        {
            //let's try minimizing percent error...
            Double sum = 0.0;
            for (int i = 0; i < data.total(); i++)
            {
                sum += (Math.Abs(data.getAbundanceTotal() * data.mu[i] - data.experimental[i]) / Math.Abs(data.experimental[i])) * 100;
            }
            //Console.WriteLine("ERROR {0}", sum);
            return sum;
        }

        static void prepOptimization(Abundance data)
        {
            //No longer needed, but feel free to add code here to set the initial
            //guesses to whatever you'd like.
            while (data.initialMax.Count() < 0.10)
            {
                data.initialMax.Add(1.0);

            }

            while (data.initialMin.Count() < 0.10)
            {
                data.initialMin.Add(0.0);
            }
        }

        static public void PerformOptimization(Abundance data)
        {
            //Reset iterations counter.
            data.resetIterations();

            //Set Initial Guesses, Min values and Max values if you need to
            prepOptimization( data );

            //Run the Optimization method
            var solution = NelderMeadSolver.Solve(x => solveAbundance(x, data), data.initialGuess.ToArray(), data.initialMin.ToArray(), data.initialMax.ToArray());
            
            //Print the exit state of the Optmization method, should say Optimal or LocalOptimal or something like that.
            Console.Write("{0}\t", solution.GetSolutionValue(0));

            //Print how many iterations occured in the optimization process.
            Console.Write("{0}\t",data.getIterations());

            //Iterate through each chemical and print the isotope
            //estimation generated by the optimization function.
            for (int i = 1; i <= data.initialGuess.Count; i++)
            {
                Console.Write("{0}\t", solution.GetValue(i));
            }

            //Go to newline.
            Console.WriteLine("");
            System.Console.ReadLine();
        }
    }
}
